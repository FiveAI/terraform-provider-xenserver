/*
 * The MIT License (MIT)
 * Copyright (c) 2016 Maksym Borodin <borodin.maksym@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

package main

import (
	"github.com/amfranz/go-xen-api-client"
	"github.com/hashicorp/terraform/helper/schema"
	"fmt"
	"strconv"
)

const (
	vifSchemaNetworkNameLabel        = "network_name_label"
	vifSchemaNetworkUUID             = "network_uuid"
	vifSchemaVMNameLabel             = "vm_name_label"
	vifSchemaVMUUID                  = "vm_uuid"
	vifSchemaMac                     = "mac"
	vifSchemaMtu                     = "mtu"
)

func resourceVIF() *schema.Resource {
	return &schema.Resource{
		Create: resourceVIFCreate,
		Read:   resourceVIFRead,
		Update: resourceVIFUpdate,
		Delete: resourceVIFDelete,
		Exists: resourceVIFExists,

		Schema: map[string]*schema.Schema{
			vifSchemaNetworkNameLabel: &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
			},
			vifSchemaNetworkUUID: &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
			},
			vifSchemaVMNameLabel: &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
			},
			vifSchemaVMUUID: &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
			},
			vifSchemaMac: &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
			},
			vifSchemaMtu: &schema.Schema{
				Type:     schema.TypeInt,
				Optional: true,
			},
		},
	}
}

func resourceVIFCreate(d *schema.ResourceData, m interface{}) error {
	c := m.(*Connection)

	var network xenAPI.NetworkRef

	hasNetName := false
	hasNetUUID := false

	netId, ok := d.GetOk(vifSchemaNetworkNameLabel)
	if(ok) {
		networks, err := c.client.Network.GetByNameLabel(c.session, netId.(string))
		if err != nil {
			return err
		}

		if len(networks) == 0 {
			return fmt.Errorf("Network %q not found!", netId)
		}

		hasNetName = true
		network = networks[0]
	}

	if !hasNetName {
		netId, ok := d.GetOk(vifSchemaNetworkUUID)
		if ok {
			_network, err := c.client.Network.GetByUUID(c.session, netId.(string))
			if err != nil {
				return err
			}
			hasNetUUID = true
			network = _network
		}
	}

	if !hasNetName && !hasNetUUID {
		return fmt.Errorf("Either %q or %q should be specified!", vifSchemaNetworkNameLabel, vifSchemaNetworkUUID)
	}

	var vm xenAPI.VMRef

	hasVMName := false
	hasVMUUID := false

	vmId, ok := d.GetOk(vifSchemaVMNameLabel)
	if(ok) {
		vms, err := c.client.VM.GetByNameLabel(c.session, vmId.(string))
		if err != nil {
			return err
		}
		hasVMName = true
		vm = vms[0]
	}

	if !hasVMName {
		vmId, ok := d.GetOk(vifSchemaVMUUID)
		if ok {
			_vm , err := c.client.VM.GetByUUID(c.session, vmId.(string))
			if err != nil {
				return err
			}
			hasVMUUID = true
			vm = _vm
		}
	}

	if !hasVMName && !hasVMUUID {
		return fmt.Errorf("Either %q or %q should be specified!", vifSchemaNetworkNameLabel, vifSchemaNetworkUUID)
	}

	mtu, ok := d.GetOk(vifSchemaMtu)

	if !ok {
		mtu = 1500
	}

	vifs, err := c.client.VM.GetVIFs(c.session, vm)
	if err != nil {
		return err
	}

	vif := xenAPI.VIFRecord{
		Network: network,
		VM: vm,
		MTU: mtu.(int),
		LockingMode: xenAPI.VifLockingModeNetworkDefault,
		Device: strconv.Itoa(len(vifs)),
	}

	mac, ok := d.GetOk(vifSchemaMac)

	if ok {
		vif.MAC = mac.(string)
		vif.MACAutogenerated = false
	} else {
		vif.MACAutogenerated = true
	}

	vifRef, err := c.client.VIF.Create(c.session, vif)
	if err != nil {
		if xenErr, ok := err.(*xenAPI.Error); ok {
			if xenErr.Code() == xenAPI.ERR_UUID_INVALID {
				d.SetId("")
				return nil
			}
		}

		return err
	}

	vifObject, err := c.client.VIF.GetRecord(c.session, vifRef)
	if err != nil {
		return err
	}

	d.SetId(vifObject.UUID)

	err = c.client.VIF.Plug(c.session, vifRef)
	if err != nil {
		return err
	}

	return nil
}

func resourceVIFRead(d *schema.ResourceData, m interface{}) error {
	c := m.(*Connection)

	vifRef, err := c.client.VIF.GetByUUID(c.session, d.Id())
	if err != nil {
		if xenErr, ok := err.(*xenAPI.Error); ok {
			if xenErr.Code() == xenAPI.ERR_UUID_INVALID {
				d.SetId("")
				return nil
			}
		}

		return err
	}

	vif, err := c.client.VIF.GetRecord(c.session, vifRef)
	if err != nil {
		return err
	}

	net, err := c.client.Network.GetRecord(c.session, vif.Network)
	if err != nil {
		return err
	}

	d.Set(vifSchemaNetworkNameLabel, net.NameLabel)

	return nil
}

func resourceVIFUpdate(d *schema.ResourceData, m interface{}) error {
	c := m.(*Connection)

	vifRef, err := c.client.VIF.GetByUUID(c.session, d.Id())
	if err != nil {
		if xenErr, ok := err.(*xenAPI.Error); ok {
			if xenErr.Code() == xenAPI.ERR_UUID_INVALID {
				d.SetId("")
				return nil
			}
		}

		return err
	}

	vif, err := c.client.VIF.GetRecord(c.session, vifRef)
	if err != nil {
		return err
	}

	d.Partial(true)

	netLabel := d.Get(vifSchemaNetworkNameLabel).(string)

	net, err := c.client.Network.GetRecord(c.session, vif.Network)
	if err != nil {
		return err
	}

	if netLabel != net.NameLabel {

		networks, err := c.client.Network.GetByNameLabel(c.session, netLabel)
		if err != nil {
			return err
		}

		network := networks[0]

		err = c.client.VIF.Destroy(c.session, vifRef)
		if err != nil {
			return err
		}

		vif.Network = network

		vifRef, err = c.client.VIF.Create(c.session, vif)
		if err != nil {
			return err
		}

		d.SetPartial(vifSchemaNetworkNameLabel)

	}

	return nil
}

func resourceVIFDelete(d *schema.ResourceData, m interface{}) error {
	c := m.(*Connection)

	vifRef, err := c.client.VIF.GetByUUID(c.session, d.Id())
	if err != nil {
		if xenErr, ok := err.(*xenAPI.Error); ok {
			if xenErr.Code() == xenAPI.ERR_UUID_INVALID {
				d.SetId("")
				return nil
			}
		}

		return err
	}

	err = c.client.VIF.Destroy(c.session, vifRef)
	if err != nil {
		return err
	}

	return nil
}

func resourceVIFExists(d *schema.ResourceData, m interface{}) (bool, error)  {
	c := m.(*Connection)

	_, err := c.client.VIF.GetByUUID(c.session, d.Id())
	if err != nil {
		if xenErr, ok := err.(*xenAPI.Error); ok {
			if xenErr.Code() == xenAPI.ERR_UUID_INVALID {
				return false, nil
			}
		}

		return false, err
	}

	return true, nil
}