/*
 * The MIT License (MIT)
 * Copyright (c) 2016 Maksym Borodin <borodin.maksym@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
package main

import (
	"fmt"
	"github.com/amfranz/go-xen-api-client"
	"strconv"
)

type Range struct {
	Min int
	Max int
}

type NetworkDescriptor struct {
	UUID        string
	Name        string
	Description string
	Bridge      string
	MTU         int

	NetworkRef  xenAPI.NetworkRef
}

type VMDescriptor struct {
	UUID          string
	Name          string
	Description   string
	PowerState    xenAPI.VMPowerState
	IsPV          bool
	StaticMemory  Range
	DynamicMemory Range
	VCPUCount     int
	VIFCount      int
	VBDCount      int
	PCICount      int
	OtherConfig   map[string]string
	XenstoreData  map[string]string
	HVMBootParameters map[string]string

	VMRef         xenAPI.VMRef
}

type VIFDescriptor struct {
	Network *NetworkDescriptor
	VM *VMDescriptor
	UUID string
	MTU int
	MAC string
	IsAutogeneratedMAC bool
	DeviceOrder int

	VIFRef xenAPI.VIFRef
}

func (this *NetworkDescriptor) Load(c *Connection) error {
	var network xenAPI.NetworkRef

	hasNetName := false
	hasNetUUID := false

	if this.Name != "" {
		networks, err := c.client.Network.GetByNameLabel(c.session, this.Name)
		if err != nil {
			return err
		}

		if len(networks) == 0 {
			return fmt.Errorf("Network %q not found!", this.Name)
		}

		hasNetName = true
		network = networks[0]
	}

	if !hasNetName {
		if this.UUID != "" {
			_network, err := c.client.Network.GetByUUID(c.session, this.UUID)
			if err != nil {
				return err
			}
			hasNetUUID = true
			network = _network
		}
	}

	if !hasNetName && !hasNetUUID {
		return fmt.Errorf("Either %q or %q should be specified!", vifSchemaNetworkNameLabel, vifSchemaNetworkUUID)
	}

	this.NetworkRef = network

	return this.Query(c)
}

func (this *NetworkDescriptor) Query(c *Connection) error {
	network, err := c.client.Network.GetRecord(c.session, this.NetworkRef)
	if err != nil {
		return err
	}

	this.UUID = network.UUID
	this.Name = network.NameLabel
	this.Description = network.NameDescription
	this.MTU = network.MTU
	this.Bridge = network.Bridge

	return nil
}

func (this *VMDescriptor) Load(c *Connection) error {
	var vm xenAPI.VMRef

	hasVMName := false
	hasVMUUID := false

	if this.Name != "" {
		vms, err := c.client.VM.GetByNameLabel(c.session, this.Name)
		if err != nil {
			return err
		}

		if len(vms) == 0 {
			return fmt.Errorf("VM %q not found!", this.Name)
		}

		hasVMName = true
		vm = vms[0]
	}

	if !hasVMName {
		if this.UUID != "" {
			_vm, err := c.client.VM.GetByUUID(c.session, this.UUID)
			if err != nil {
				return err
			}
			hasVMUUID = true
			vm = _vm
		}
	}

	if !hasVMName && !hasVMUUID {
		return fmt.Errorf("Either %q or %q should be specified!", vifSchemaNetworkNameLabel, vifSchemaNetworkUUID)
	}

	this.VMRef = vm

	return this.Query(c)
}

func (this *VMDescriptor) Query(c *Connection) error {
	vm, err := c.client.VM.GetRecord(c.session, this.VMRef)
	if err != nil {
		return err
	}

	this.UUID = vm.UUID
	this.Name = vm.NameLabel
	this.Description = vm.NameDescription
	this.PowerState = vm.PowerState
	this.IsPV = vm.PVBootloader != ""
	this.VCPUCount = vm.VCPUsMax
	this.StaticMemory = Range{
		Min: vm.MemoryStaticMin,
		Max: vm.MemoryStaticMax,
	}
	this.DynamicMemory = Range{
		Min: vm.MemoryDynamicMin,
		Max: vm.MemoryDynamicMax,
	}
	this.VIFCount = len(vm.VIFs)
	this.VBDCount = len(vm.VBDs)
	this.PCICount = len(vm.AttachedPCIs)
	this.OtherConfig = vm.OtherConfig
	this.XenstoreData = vm.XenstoreData
	this.HVMBootParameters = vm.HVMBootParams

	return nil
}

func (this *VMDescriptor) UpdateMemory(c *Connection) error {
	return c.client.VM.SetMemoryLimits(c.session,
		this.VMRef,
		this.StaticMemory.Min,
		this.StaticMemory.Max,
		this.DynamicMemory.Min,
		this.DynamicMemory.Max)
}

func (this *VMDescriptor) UpdateVCPUs(c *Connection) error {
	if err := c.client.VM.SetVCPUsMax(c.session, this.VMRef, this.VCPUCount);  err != nil {
		return err
	}
	if err := c.client.VM.SetVCPUsAtStartup(c.session, this.VMRef, this.VCPUCount);  err != nil {
		return err
	}

	return nil
}

func (this *VIFDescriptor) Load(c *Connection) error {
	var VIFRef xenAPI.VIFRef
	var err error
	if VIFRef, err = c.client.VIF.GetByUUID(c.session, this.UUID); err != nil {
		return err
	}
	this.VIFRef = VIFRef

	return this.Query(c)
}

func (this *VIFDescriptor) Query(c *Connection) error {
	var vif xenAPI.VIFRecord
	var err error
	if vif, err = c.client.VIF.GetRecord(c.session, this.VIFRef); err != nil {
		return err
	}

	this.UUID = vif.UUID
	this.MTU = vif.MTU
	this.DeviceOrder, err = strconv.Atoi(vif.Device) // Error ignored, should not occur
	this.IsAutogeneratedMAC = vif.MACAutogenerated
	this.MAC = vif.MAC

	if this.Network == nil {
		this.Network = &NetworkDescriptor{
			NetworkRef: vif.Network,
		}
		if err := this.Network.Query(c); err != nil {
			return err
		}
	}

	if this.VM == nil {
		this.VM = &VMDescriptor{
			VMRef: vif.VM,
		}
		if err := this.VM.Query(c); err != nil {
			return err
		}
	}

	return nil
}